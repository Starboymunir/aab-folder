// scripts/patch-android.mjs
import fs from 'fs/promises';
import path from 'path';
import crypto from 'crypto';
import { spawn } from 'child_process';

const zipPathDefault = "/mnt/c/Users/owner/Downloads/gradle-8.14.3-bin.zip";
const isCI = !!process.env.EAS_BUILD; // true on EAS cloud builds


function encUrl(p) {
  return 'file://' + p
    .replace(/\\/g,'/')
    .replace(/ /g,'%20')
    .replace(/\(/g,'%28')
    .replace(/\)/g,'%29');
}
const exists = async (p) => { try { await fs.access(p); return true; } catch { return false; } };
const read = (f) => fs.readFile(f, 'utf8');
const write = (f, t) => fs.writeFile(f, t, 'utf8');

async function run(cmd, args, opts = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(cmd, args, { stdio: 'inherit', ...opts });
    child.on('close', code => code === 0 ? resolve() : reject(new Error(`${cmd} ${args.join(' ')} exited ${code}`)));
  });
}

async function sha256(file) {
  const buf = await fs.readFile(file);
  return crypto.createHash('sha256').update(buf).digest('hex');
}

async function findAndroidDir(cwd) {
  // In local EAS managed builds, android/ is under CWD (temp build dir)
  const direct = path.join(cwd, 'android');
  if (await exists(direct)) return direct;

  // If not generated yet and we're in the --mode=pre phase, run prebuild now
  // (If mode=post, prebuild should have run already; still try once.)
  console.log('android/ not present → running expo prebuild');
  await run('bash', ['-lc', 'CI=1 npx expo prebuild --platform android --clean --skip-install'], {
    env: { ...process.env, CI: '1' },
  });

  if (await exists(direct)) return direct;
  throw new Error('android/ was not generated by prebuild.');
}

function patchSettingsText(settingsText, relGradlePluginPath) {
  let s = settingsText;

  // Ensure pluginManagement + repositories present
  if (!/pluginManagement\s*\{/.test(s)) {
    s = `pluginManagement {\n  repositories { google(); mavenCentral(); gradlePluginPortal() }\n}\n\n` + s;
  } else if (!/repositories\s*\{[\s\S]*mavenCentral\(\)/.test(s)) {
    s = s.replace(
      /pluginManagement\s*\{/,
      `pluginManagement {\n  repositories { google(); mavenCentral(); gradlePluginPortal() }`
    );
  }

  // Ensure includeBuild points to @react-native/gradle-plugin using the computed relative path
  const includeLine = `includeBuild("${relGradlePluginPath}")`;
  if (!new RegExp(`includeBuild\\(["']${relGradlePluginPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}["']\\)`).test(s)) {
    // place it at the top-level (safe across Gradle versions)
    if (!/^\s*includeBuild\(/m.test(s)) {
      s = includeLine + '\n' + s;
    } else {
      s = s.replace(/^\s*includeBuild\(.*\)\s*$/m, includeLine);
      if (!s.includes(includeLine)) s = includeLine + '\n' + s;
    }
  }

  // Ensure the plugin is applied
  if (!/plugins\s*\{[\s\S]*com\.facebook\.react\.settings/.test(s)) {
    if (/plugins\s*\{/.test(s)) {
      s = s.replace(/plugins\s*\{/, `plugins {\n  id("com.facebook.react.settings")`);
    } else {
      s = `plugins {\n  id("com.facebook.react.settings")\n}\n\n` + s;
    }
  }

  // Ensure basic lines exist (harmless if duplicated)
  if (!/rootProject\.name\s*=/.test(s)) s += `\nrootProject.name = "Kingzdata"`;
  if (!/include\s*\(\s*['"]\:app['"]\s*\)/.test(s)) s += `\ninclude(':app')\n`;

  return s;
}

async function patchSettings(androidDir, nodeModulesDir) {
  const settingsPath = path.join(androidDir, 'settings.gradle');
  const pluginDir = path.join(nodeModulesDir, '@react-native', 'gradle-plugin');
  if (!(await exists(pluginDir))) {
    throw new Error(`Missing @react-native/gradle-plugin at ${pluginDir}`);
  }
  const rel = path.posix.normalize(
    path.relative(androidDir, pluginDir).split(path.sep).join(path.posix.sep)
  ); // e.g. "../node_modules/@react-native/gradle-plugin"

  let original = '';
  if (await exists(settingsPath)) original = await read(settingsPath);

  const patched = patchSettingsText(original, rel);
  await write(settingsPath, patched);
  console.log(`✅ Patched settings.gradle → includeBuild("${rel}") + react settings plugin`);
}

async function patchWrapper(androidDir, zipPath) {
  const wrapper = path.join(androidDir, 'gradle', 'wrapper', 'gradle-wrapper.properties');
  await fs.mkdir(path.dirname(wrapper), { recursive: true });

  let txt = '';
  if (await exists(wrapper)) txt = await read(wrapper);
  const distUrl = encUrl(zipPath);
  const hash = await sha256(zipPath);

  if (!/distributionBase=/.test(txt)) {
    txt += 'distributionBase=GRADLE_USER_HOME\n';
    txt += 'distributionPath=wrapper/dists\n';
    txt += 'zipStoreBase=GRADLE_USER_HOME\n';
    txt += 'zipStorePath=wrapper/dists\n';
  }
  txt = txt.replace(/^distributionUrl=.*$/m, `distributionUrl=${distUrl}`);
  if (/^distributionSha256Sum=/m.test(txt)) {
    txt = txt.replace(/^distributionSha256Sum=.*$/m, `distributionSha256Sum=${hash}`);
  } else {
    txt += `distributionSha256Sum=${hash}\n`;
  }
  if (!/^\s*networkTimeout=\d+/m.test(txt)) txt += 'networkTimeout=60000\n';

  await write(wrapper, txt);
  console.log(`✅ Patched gradle-wrapper.properties → file:// ZIP + sha256`);
}

(async () => {
  const mode = process.argv.includes('--mode=post') ? 'post' : 'pre';
  const cwd = process.cwd();
  const gradleZip = process.env.GRADLE_ZIP_PATH || zipPathDefault;
  const hasGradleZip = await exists(gradleZip);
  // sanity
 
    // On CI (EAS), if no GRADLE_ZIP_PATH is provided, skip wrapper patch entirely.
  if (isCI && !hasGradleZip) {
    console.log('EAS CI detected and no GRADLE_ZIP_PATH provided → skipping wrapper patch.');
  }


  // Ensure node_modules exists in the temp build dir (EAS local installs here)
  const nodeModules = path.join(cwd, 'node_modules');
  if (!(await exists(nodeModules))) {
    throw new Error(`node_modules not found at ${nodeModules}`);
  }

  const androidDir = await findAndroidDir(cwd); // runs prebuild in "pre" if needed

  // Always re-patch right before build (mode=post), because prebuild may overwrite settings
  await patchSettings(androidDir, nodeModules);
   if (hasGradleZip) {
    await patchWrapper(androidDir, gradleZip);
  } else {
    console.log('Skipping patchWrapper (no gradle zip available).');
  }

  console.log(`✅ patch-android done (mode=${mode})`);
})().catch(e => {
  console.error('patch-android.mjs failed:', e);
  process.exit(1);
});
